using System.Text;using System.Collections.Generic;using System;namespace Putki{	// Implemented by app.	public interface TypeLoader	{		void ResolveFromPackage(int type, object obj, Putki.Package pkg);		object LoadFromPackage(int type, Putki.PackageReader reader);	}		public class PackageReader	{		static UTF8Encoding enc = new UTF8Encoding();		byte[] data;		int pos;		public PackageReader(byte[] _data)		{			data = _data;			pos = 0;		}				public int GetPosition()		{			return pos;		}		public int ReadInt32()		{			int val = data[pos] + (data[pos + 1] << 8) + (data[pos + 2] << 16) + (data[pos + 3] << 24);			pos += 4;			return val;		}		public int ReadInt16()		{			int val = data[pos] + ((int)data[pos + 1] << 8);			pos += 2;			return val;		}		public byte ReadByte()		{			return data[pos++];		}		public float ReadFloat()		{			float f = System.BitConverter.ToSingle(data, pos);			pos += 4;			return f;		}		public string ReadString()		{			return ReadString(ReadInt32());		}		public string ReadString(int bytes)		{			byte[] tmp = new byte[bytes - 1];			for (int i = 0;i < bytes - 1;i++)			{				tmp[i] = data[pos + i];			}			pos += bytes;			return enc.GetString(tmp);		}		public void Skip(int bytes)		{			pos += bytes;		}		public PackageReader CloneAux(int ofs)		{			PackageReader r = new PackageReader(data);			r.pos = pos + ofs;			return r;		}		public void MoveTo(PackageReader rdr)		{			pos = rdr.pos;		}	}	public class Package	{		// package slots			const int FLAG_PATH       = 1;		const int FLAG_EXTERNAL   = 2;		const int FLAG_INTERNAL   = 4;		const int FLAG_UNRESOLVED = 8;				public class Slot		{			public string path;			public object inst;			public int type;			public int flags;		};		public Slot[] m_slots;		string[] m_pathTable;		List<Package> m_extRefs = null;		List<string> m_unresolved = null;		bool m_gotUnresolved = false;		public List<string> TryResolveWithRefs(List<Package> extRefs, TypeLoader loader)		{			m_extRefs = extRefs;			m_unresolved = new List<string>();			for (int i = 0;i < m_slots.Length;i++)			{				loader.ResolveFromPackage(m_slots[i].type, m_slots[i].inst, this);			}			List<string> r = m_unresolved;			m_unresolved = null;			m_extRefs = null;			return r;		}		public string RootObjPath()		{			return m_slots[0].path;		}		public object ResolveSlot(int index)		{			if (index == 0)			{				// null pointer				return null;			}			else if (index > 0 && index <= m_slots.Length)			{				if ((m_slots[index - 1].flags & FLAG_UNRESOLVED) != 0)				{					return Resolve(m_slots[index - 1].path);				}				else				{					// resolve by path instead if in that mode, and we know the path of the object.					if (m_extRefs != null && m_slots[index - 1].path.Length > 0)					{						return Resolve(m_slots[index - 1].path);					}					return m_slots[index - 1].inst;				}			}						return null;		}		public object Resolve(string path)		{			if (m_extRefs != null)			{				foreach (Package p in m_extRefs)				{					foreach (Slot s in p.m_slots)					{						if (s.inst != null &&s.path == path)						{							return s.inst;						}					}				}			}			foreach (Slot s in m_slots)			{				if (s.inst != null && s.path == path)				{					return s.inst;				}			}			if (path == "")			{				Console.WriteLine("EMPTY PATH!");				return null;			}			m_gotUnresolved = true;			if (m_unresolved != null)			{				m_unresolved.Add(path);			}			return null;		}		public bool LoadFromBytes(byte[] data, TypeLoader loader)		{			PackageReader rdr = new PackageReader(data);			// No support for external file refs yet.						rdr.ReadInt32(); // tag			rdr.ReadInt32(); // flags			rdr.ReadInt32(); // hdr size			rdr.ReadInt32(); // data size			int numImports = rdr.ReadInt16();						if (numImports != 0)			{				Console.WriteLine("Package has imports, unsupported now!");				return false;			}						int slots = rdr.ReadInt16();			m_slots = new Slot[slots];						for (int i = 0;i < slots;i++)			{				m_slots[i] = new Slot();								m_slots[i].flags = rdr.ReadInt16();				if ((m_slots[i].flags & FLAG_PATH) != 0)				{					m_slots[i].path = rdr.ReadString(rdr.ReadInt16());				}								// external flag could be set				if ((m_slots[i].flags & FLAG_EXTERNAL) != 0)				{					Console.WriteLine("External resources not supported!");					return false;				}				else if ((m_slots[i].flags & FLAG_INTERNAL) != 0)				{					rdr.ReadInt32(); // beg in data section					rdr.ReadInt32(); // end in data section					m_slots[i].type = rdr.ReadInt16();				}			}			// Now we assume they are all just lined up after this!			for (int i = 0;i < slots;i++)			{				if ((m_slots[i].flags & FLAG_INTERNAL) != 0)					m_slots[i].inst = loader.LoadFromPackage(m_slots[i].type, rdr);			}						// Now we assume they are all just lined up after this!			for (int i = 0;i < slots;i++)			{				if ((m_slots[i].flags & FLAG_INTERNAL) != 0)				{					loader.ResolveFromPackage(m_slots[i].type, m_slots[i].inst, this);				}			}						Console.WriteLine("LoadFromBytes: Got unresolved? " + m_gotUnresolved);			Console.WriteLine("Loaded " + slots + " slots");			return !m_gotUnresolved;		}		public void Release()		{			m_slots = null;		}	}}